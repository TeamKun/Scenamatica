
# シナリオを構成している要素

Scenamatica のシナリオを構成する要素について説明しています。

---

## 概要 {#about}

シナリオは、以下の要素で構成されています。

+ 名前
+ 説明
+ [トリガ](#trigger)
+ [コンテキスト](#context)
+ 本[シナリオ](#scenario)
+ [実行条件](#runif)

:::info

本[シナリオ](#scenario)は、プラグインの機能を検証する主要な[シナリオ](#scenario)のことです。

:::

## シナリオ {#scenario}

:::caution

Scenamatica で使用される「シナリオ」という語は、以下の２つの意味を持ちます。

1. [コンテキスト](#context) や [トリガー](#trigger) などの概念を含む、包括的な意味でのシナリオ。
2. [シナリオファイル](#scenario-file) に記述された、プラグインの振る舞いを検証するための一連のアクションのこと。

この項目では、後者の意味での「シナリオ」について説明しています（このページ全体では、前者のシナリオの要素について説明しています）。
:::

シナリオは、プラグインの代表的な I/O を定義したものです。
Scenamatica は、これを一つ一つ実行/検証 し、プラグインの振る舞いを検証します。
実行/検証に失敗した場合、 Scenamatica はプラグインが正しく動作していないと判断し、エラーを報告します。

各シナリオは、[シナリオタイプ](#scenario-type) と[アクション](#action-concept) および タイムアウト(ms)で構成されています。

## シナリオタイプ {#scenario-type}

シナリオタイプは、そのシナリオの振る舞いを決めて検証事項を定義するものです。
シナリオタイプによって、シナリオの成功条件や失敗条件が異なります。

### アクション実行(`execute`) タイプ {#scenario-type-action-execution}

アクション実行(`execute`) タイプは、引数に指定されたアクションを実行し、完了するまでまたはタイムアウトまで待機します。

+ シナリオの成功条件
  * アクションが完了する。
+ シナリオの失敗条件
  * アクションがタイムアウトする。
  * アクションの実行時に例外またはエラーが発生する。

### アクション実行期待(`expect`) タイプ {#scenario-type-action-execution-expect}

アクション実行期待(`expect`) タイプは、引数に指定されたアクションがプラグインによって実行されるか検証します。
指定されたアクションが（プラグインによって）実行されるまで、もしくはタイムアウトするまで待機されます。

:::warning

**後に実行されるべきアクションが繰り上げられて先に実行された場合、このシナリオは失敗します。**

例えば、以下のようなシナリオがあったとします：

+ アクション A を実行する
+ アクション B の実行を期待する （プラグインによって実行されるか）
+ アクション C を実行を期待する （プラグインによって実行されるか）

このとき、プラグインによって A -> C -> B の順番で実行された場合、このシナリオは C の実行とともに失敗します。

:::

:::caution

失敗になるのはアクションの実行順序がおかしい場合のみです。

例えば「指定されたメッセージが送信されるか期待する」シナリオで、指定されたものと違うメッセージが送信された場合でも、即座に失敗になることはありません。
そのあとに正しいメッセージが時間内に送信された場合、このシナリオは成功します。

:::

+ シナリオの成功条件
  * 対象のプラグインによってアクションが実行される。
+ シナリオの失敗条件
  * 検証がタイムアウトする。
  * 他のアクションが先に実行される。

### コンディション要求(`require`) タイプ {#scenario-type-condition-require}

コンディション要求(`require`) タイプは、引数に指定されたコンディションが**既に**満たされているか検証します。  
この機能は、前述の「アクション実行期待」を応用したものです。  
例えば、以下のようなシナリオがあったとします：

+ アクション A を実行する
+ プレイヤ P がアイテム X を持っているか確認する （本機能）
+ アクション B を実行する

このとき、プレイヤ P がアイテム X を持っているかどうかを確認します。  
シナリオ A の実行後すぐに プレイヤ P がアイテム X を持っていない場合、このシナリオは失敗します。

:::caution
このタイプは、そのシナリオに到達する前にコンディションを満たしていることを確認するためのものです。


そのため、満たされるまで待機したり、タイムアウトまで待機する機能はありません。

:::

:::tip 「アクション実行期待」タイプとの違い

「アクション実行期待」タイプは、プラグインによってアクションが実行されるまで検証します。また、実行されるまで待機されます。  
一方、このタイプは、アクションの実行者を考慮せず、コンディションが満たされているかどうかを検証します。さらに満たされるまで待機されません。

:::

+ シナリオの成功条件
  * コンディションが満たされている。
+ シナリオの失敗条件
  * （このシナリオに到達時に）コンディションが満たされていない。

## トリガ {#trigger}

トリガは、[シナリオ](#scenario) の実行を開始するための条件です。  
手動実行された時や、イベントの発生、タイマーの経過などでトリガが発火し、シナリオが実行されます。

:::tip

トリガは、[シナリオ](#scenario) に対して複数設定できます。  
この場合、そのうちどれか一つが発火した時にシナリオが実行されます。

:::

:::info

手動実行を含む、いかなるシナリオにもトリガが必要です。

:::

### 事前/事後シナリオ機能 {#before-after-scenarios}

前述の通り、１つのシナリオは複数のトリガを持つことができます。
ですが、特定のトリガによって実行されたシナリオの前や後に特別なシナリオを実行したい場合があります。  
この機能は、このような要求を実現するために用意されています。

### 条件付きトリガ機能 {#conditional-triggers}

トリガの発火条件に、追加で条件を指定できます。  
これは、シナリオの[実行条件](#runif)機能と同じです。詳しくは、[こちら](#runif)を参照してください。

## コンテキスト {#context}

コンテキストは、[シナリオ](#scenario) を実行する環境や、登場するアクターを包括的に定義するものです。  
シナリオの実行時にコンテキストが作成され、終了時に破棄されます。

:::tip

１つのシナリオに１つのコンテキストのみ割り当てられます。  
また、事前/事後シナリオ機能で実行されるシナリオは、本シナリオと同じコンテキストを使用します。

:::

これは主に２つの要素を持ちます。

### ステージ {#stage}

ステージは、[シナリオ](#scenario) を実行するワールドのことです。シナリオ開始時に生成され、終了時にディレクトリごと削除されます。  
この機能は、シナリオ実行時のワールドの変更を完全に隔離し、実行後にワールドの状態を元に戻すために用意されています。

ステージの作成は以下の２方式があります。

1. 既存の Minecraft ワールドをコピーする。  
  既にサーバに狼怒されているワールドをコピーすることで、建築物等をそのまま利用できます。
2. シード値/環境等を指定して新規に生成する。  
  この方式はシナリオの実行時に毎回ワールドを生成するので、毎回違う環境で実行できます。
  ですが、ワールドの生成は時間とサーバ・リソースがかかるため、非推奨です（今後もサポートは継続されます）。

## 実行条件 {#runif}

シナリオを条件付きで実行します。
指定は [コンディション要求(`require`) タイプ](#scenario-type-condition-require) のアクションで行います。  
実行時に条件を満たしていなかった場合そのテストは `SKIPPED` で終了し、エラーにはなりません。

:::tip

シナリオ及び各トリガの実行条件は、**コンテキストの生成後**に評価されます。  
これは、実行条件によってはコンテキストが必要な場合があるためです。

:::

### アクター {#actor}

アクターは、[シナリオ](#scenario) に登場する擬似的なプレイヤーです。シナリオ開始時にログインし、終了時にログアウトします。
また、アクタ－のログアウト時には、実績や権限、ほかのすべてのアクターに関するプレイヤーデータは削除されます。

この機能で生成されるプレイヤーは、通常のプレイヤーと同様に Minecraft サーバにログインします。
ですが、実際のソケット通信は行われず、 NMS を使用して Minecraft サーバの通信をエミュレートします。  
そのため、アクターに対して送られるパケットは、 `Packet(In/Out)KeepAlive` を除いて全て捨てられます。
 
:::tip

プラグイン側から `PlayerInventory#setHeldItemSlot(int)` などを使用した場合に `PlayerItemHeldEvent` が発火しないバグ（だと思っている）が存在します。
そのため、 Scenamatica ではこれを回避し、 アクターに対するスロットの変更時に `PlayerItemHeldEvent` を発火させるようにしています。

ただし, 同イベントのフィールドである `previousSlot` は技術的制約により `currentSlot` と同じ値になります。
:::
