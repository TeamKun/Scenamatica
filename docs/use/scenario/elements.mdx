import BelowDocument from "../../../src/components/BelowDocument";

# シナリオの要素

Scenamatica のシナリオを構成する要素について説明しています。

---

## 概要 {#about}

:::tip


このページでは、シナリオの実体的な要素について説明しています。  
シナリオファイルの構文や書き方については以下のページを参照してください。

+ [シナリオファイルの構文](file-syntax)
+ [チュートリアル：最初のシナリオを書いてみる](/docs/getting-started/writing-my-first-scenario)

:::

シナリオは以下の要素で構成されています。

+ 名前
+ 説明
+ [トリガ](#trigger)
+ [実行順](#order)
+ [コンテキスト](#context)
+ メイン[シナリオ](#scenario)
+ [実行条件](#conditional-execution)

:::info

メイン[シナリオ](#scenario)は、プラグインの機能を検証する主要な[シナリオ](#scenario)のことです。

:::

## トリガ {#trigger}

トリガは、[シナリオ](#scenario) の実行を開始するための発火条件です。  
手動実行や特定のアクションの発火など、様々なトリガがあります。

<BelowDocument docId={"use/scenario/triggers"}
               anchor="triggers"
               label={"トリガの種類"}
/>
<br />

:::tip

トリガは、[シナリオ](#scenario) に対して複数設定できます。  
この場合、そのうちどれか一つが発火した時にシナリオが実行されます。

:::

:::info

手動実行を含む、いかなるシナリオにも一つ以上のトリガが必要です。

:::

### 事前/事後シナリオ機能 {#before-after-scenarios}

本シナリオの実行前後に実行されるシナリオを、トリガごとに設定できます。  
両方設定した場合、`事前シナリオ -> 本シナリオ -> 事後シナリオ` の順番で同期的に実行されます。

:::info 例

例えば、プレイヤのキル時のアクションを検証するシナリオを考えます。  
このとき、トリガは「手動実行」および「プレイヤの死亡」を設定します。  
シナリオが手動実行されるとき、実際にはプレイヤが死亡していないため、事前トリガ機能を用いてプレイヤを死亡させます。

```yaml
# ...
on:
  - type: on_action
    action: player_death
    with:
      target: Actor001
  - type: manual_dispatch
    before:
      - type: execute # 手動実行のときはプレイヤが死亡した事実は無いため、事前にプレイヤを死亡させる。
        action: player_death
        with:
          target: Actor001

# ...
scenario:
  - type: expect
    action: message
    with:
      recipient: Actor001
      message: "You died!" # プラグインによって、死亡時に "You died!" というメッセージが送信されることを期待する。
```

:::

### 条件付きトリガ機能 {#conditional-triggers}

トリガの発火条件に、追加で条件を指定できます。  
これは、シナリオの[実行条件](#conditional-execution)機能と同じですが、トリガごとに設定できるという点で異なります。
詳しくは、[こちら](#conditional-execution)を参照してください。

## 実行順 {#order}

実行順は、[シナリオ](#scenario) の同一セッション内の実行順序を指定するものです。

シナリオは、[シナリオセッション](./#scenario-session) と呼ばれる複数のシナリオの複合単位で実行されます。
同じタイミングかつ同じトリガで実行されたシナリオ（例：プラグインのロード時に発火するシナリオ）は、同一セッションに属します。  
この設定により、ロード時のシナリオの実行順序を指定したりできます。

<BelowDocument docId={"use/scenario/file-syntax"}
               anchor="apex-order"
               label={"シナリオファイルの構文 | 実行順"}
/>


## コンテキスト {#context}

コンテキストは、[シナリオ](#scenario) を実行する[ステージ](#stage)（ワールド）や、登場する[アクター](#actor) （プレイヤ）などを定義するものです。
シナリオの実行前に実行ごとの一意なコンテキストが作成され、終了時に破棄されます。

現在は [ステージ](#stage) と [アクター](#actor) の２要素で構成されています。

:::tip

１つのシナリオに１つのコンテキストが割り当てられます。  
また、事前/事後シナリオ機能で実行されるシナリオは、本シナリオと同じコンテキストを使用します。

:::

### ステージ {#stage}

ステージは、[シナリオ](#scenario) を実行するワールドのことです。シナリオ開始時に生成され、終了時にディレクトリごと削除されます。  
この機能は、シナリオ実行時のワールドの変更を完全に隔離し、実行後にワールドの状態を元に戻すために用意されています。

ステージの作成は以下の２方式があります。

1. 既存の Minecraft ワールドをコピーする。  
  既にサーバに存在するワールドをコピーすることで、建築物やエンティティをそのまま利用できます。
2. シード値/環境等を指定して新規に生成する。  
  この方式はシナリオの実行時に毎回ワールドを生成するので、毎回違う環境で実行できます。ただし、ワールドの生成はパフォーマンスに影響するため注意してください。

### アクター {#actor}

アクターは、[シナリオ](#scenario) に登場する擬似的なプレイヤーです。シナリオ開始時に作成され、終了時に破棄されます。
また、アクタ－のログアウト時には、実績や権限、ほかのすべてのアクターに関するプレイヤーデータは削除されます。

この機能で生成されるプレイヤーは、通常のプレイヤーと同様に Minecraft サーバにログインします。
ですが、実際のソケット通信は行われず、 NMS を使用して Minecraft サーバの通信をエミュレートします。  
そのため、アクターに対して送られるパケットは、 `Packet(In/Out)KeepAlive` を除いて全て破棄されます。
 
:::tip

プラグイン側から `PlayerInventory#setHeldItemSlot(int)` などを使用した場合に `PlayerItemHeldEvent` が発火しないバグ（だと思っている）が存在します。
そのため、 Scenamatica ではこれを回避し、アクターに対するスロットの変更時に `PlayerItemHeldEvent` を発火させるようにしています。

ただし、同イベントのフィールドである `previousSlot` は技術的制約により `currentSlot` と同じ値になります。
:::

## シナリオ {#scenario}

開発者は、プラグインの大まかな入出力をシナリオとして記述します。
Scenamatica は、これらを一つ一つ実行/検証 し、プラグインの振る舞いを検証します。
実行/検証に失敗した場合、 Scenamatica はプラグインが正しく動作していないと判断し、エラーを報告します。

各シナリオは、[シナリオタイプ](#scenario-type) と[アクション](#action-concept) および タイムアウト\(ms) を指定して構成されます。

シナリオタイプは、そのアクション振る舞いを決めて検証事項を定義するものです。  
アクションは文字通り、プラグインに対して行われる/検証される動作（e.g. プレイヤのゲームモードの変更）を指定します。

:::caution

Scenamatica で使用される「シナリオ」という語は、以下の２つの意味を持ちます。

1. [コンテキスト](#context) や [トリガー](#trigger)、メイン[シナリオ](#scenario) などを含む、包括的な意味でのシナリオ。  
シナリオファイルに記述される全体のこと。
2. プラグインの振る舞いを検証するためのアクションとその振る舞いの組。

この項目では、後者の意味での「シナリオ」について説明しています。

```yaml

# このファイル自体を、シナリオファイルで記述された「シナリオ」と呼ぶ。

#...

scenario:
- type: execute
  action: player_death
  with:
    target: Actor001 
  # ↑の一つ一つを「シナリオ」と呼ぶ。
```

:::

## シナリオの種類 {#scenario-type}

全てのシナリオは以下の３つのタイプのいずれかに分類されます。詳しくは、各項目の説明を参照してください。

1. [アクション実行(`execute`)](#scenario-type-action-execution)
2. [アクション実行期待(`expect`)](#scenario-type-action-execution-expect)
3. [コンディション要求(`require`)](#scenario-type-condition-require)

### アクション実行(`execute`) タイプ {#scenario-type-action-execution}

アクション実行(`execute`) タイプは、引数に指定されたアクションを実行し、完了するまでまたはタイムアウトするまで待機します。  
Scenamatica がテスト対象のプラグイン機能の実行を発火させるために使用します。

+ シナリオの成功条件
1. アクションの実行が例外またはエラーなしで完了する。
+ シナリオの失敗条件
1. アクションの実行がタイムアウトする。
2. アクションの実行時に例外またはエラーが発生する。

### アクション実行期待(`expect`) タイプ {#scenario-type-action-execution-expect}

アクション実行期待(`expect`) タイプは、アクションが**プラグインによって**実行されるかどうかを検証します。  
指定されたアクションが実行されるまで、もしくはタイムアウトするまで次のシナリオの実行を待機します。

+ シナリオの成功条件
1. 対象のプラグインによってアクションが実行される。
+ シナリオの失敗条件
1. 検証がタイムアウトする。
2. 後述された実行期待シナリオ(`expect`)のアクションが先に実行される（詳細後述）。

:::warning 後に実行されるべきアクションが繰り上げられて先に実行された場合、このシナリオは失敗します。

例えば、以下のようなシナリオがあったとします：

+ アクション A を実行する
+ アクション B の実行を（プラグインによって行われるか）期待する
+ アクション C を実行を（〃）期待する

このとき、プラグインが機能を C -> B の順番で実行した場合、このシナリオは C の実行とともに失敗します。

ただし、実行が失敗するのは、アクションの実行順序がおかしい場合のみです。  
例えば「指定されたメッセージ "Hoge" が送信されること」シナリオを後に期待している場合に "Fuga" というメッセージが送信されても、  
このシナリオは即座に**失敗しません**。
そのあとに正しいメッセージが時間内に送信された場合、このシナリオは**成功**します。
:::

### コンディション要求(`require`) タイプ {#scenario-type-condition-require}

コンディション要求(`require`) タイプは、引数に指定されたコンディションが**既に**満たされているか検証します（例：プレイヤが既に死亡しているか/ゲームモードが既にスペクテイターであるか等）。
この機能は、前述の「アクション実行期待」を応用したもので、タイムアウトが `0`(固定) であることを除いて、ほとんど同じです。

例えば、以下のようなシナリオがあったとします：
+ アクション A を実行する
+ プレイヤ P がアイテム X を持っていることを**要求する**
+ アクション B を実行する

このとき、Scenamatica はプレイヤ P がアイテム X を持っているかどうかを確認します。  
シナリオ A の実行完了と同じタイミング（同チック）に プレイヤ P がアイテム X を持っていない場合、このシナリオは失敗します。

+ シナリオの成功条件
1. コンディションが（このシナリオの到達時に）満たされている。
+ シナリオの失敗条件
1. コンディションが（このシナリオの到達時に）満たされていない。

:::caution
このタイプはそのシナリオに到達する前にコンディションを満たしていることを確認するためのものです。

そのため、満たされるまで待機したり、タイムアウトまで待機する機能はありません。  
その場合は、代わりに[アクション実行期待(`expect`)](#scenario-type-action-execution-expect) タイプを使用してください。
:::

:::info 使用例

+ [条件付き実行](#conditional-execution)の条件の指定
+ JUnit のアサーションのような使用法

:::

### シナリオの例

#### 使用例：[アクション実行(`execute`)](#scenario-type-action-execution) タイプの [プレイヤの死亡およびキル](/docs/use/scenario/actions/player#death) アクション

この場合、 Scenamatica は対象のプレイヤを殺害します。殺害に成功した場合、シナリオは成功となります。

#### 使用例：[アクション実行期待(`expect`)](#scenario-type-action-execution-expect) タイプの [プレイヤの死亡およびキル](/docs/use/scenario/actions/player#death) アクション

この場合、 Scenamatica はテスト対象のプラグインにより対象のプレイヤが殺害されるまで待機します。
殺害された場合、シナリオは成功となります。  
一定時間が経過しても殺害されなかったり、**ファイルに後述されている他のシナリオが先に実行された場合**、シナリオは**失敗**となります。

#### 使用例：[コンディション要求(`require`)](#scenario-type-condition-require) タイプの [プレイヤの死亡およびキル](/docs/use/scenario/actions/player#death) アクション

この場合、 Scenamatica はプレイヤが既に死亡しているかどうかを確認します。

:::caution

全てのアクションが全てのシナリオタイプで使用できるわけではありません。  
例えば、[メッセージ送信アクション](/docs/use/scenario/actions/#message_) は、[コンディション要求(`require`)](#scenario-type-condition-require) タイプでは使用できません。  
これは、Scenamatica が既に送信されたメッセージを確認できないためです。

詳しくは各アクションのドキュメントを参照してください。

:::

## 条件付き実行 {#conditional-execution}

指定の条件を満たした場合にのみシナリオを実行します。[コンディション要求(`require`)](#scenario-type-condition-require) タイプのシナリオに対応したアクションで指定子ます。  
実行時に条件を満たしていなかった場合、そのテストは `SKIPPED` で終了するため、**失敗にはなりません**。

:::tip

シナリオ及び各トリガの実行条件は、**コンテキストの準備後**に評価されます。  
これは、条件の種類によってはコンテキストが必要な場合があるためです。

:::
