---
sidebar_position: 2
---


import BelowDocument from "/src/components/BelowDocument";

# シナリオの要素

Scenamatica のシナリオを構成する要素について説明しています。

---

:::tip


このページでは、シナリオの具体的な要素について説明しています。  
シナリオファイルの構文や実践的な書き方については以下のページを参照してください。

+ [シナリオファイルの構文](/docs/use/scenario/scenario-file)
+ [チュートリアル：最初のシナリオを書いてみる](/docs/getting-started/tutorials/writing-my-first-scenario)

:::

## 概要 {#about}

シナリオは以下の要素で構成されています。

+ 名前  
  シナリオについての一意な名前です。
+ 説明  
  シナリオについての、人間が読める説明です。
+ [トリガ](/docs/use/scenario/trigger)
+ [実行順](#order)
+ [コンテキスト](#context)
+ メイン[シナリオ](#scenario)  
  プラグインの機能を検証する主要な[シナリオ](#scenario)のことです。
+ [実行条件](#conditional-execution)


## シナリオ {#scenario}

プラグイン開発者は、プラグインの大まかな入出力をシナリオとして記述します。
そして Scenamatica はこれらを一つ一つ実行・検証し、プラグインの振る舞いをテストします。
実行・検証に失敗した場合は、 Scenamatica はプラグインが正しく動作していないと判断し、シナリオ実行の失敗を報告します。

各シナリオは、次の３つの要素で構成されています。

+ [シナリオタイプ](#scenario-type)
+ [アクション](/docs/use/scenario/actions)
+ タイムアウト（ms）
+ [実行条件](#conditional-execution)

シナリオタイプは、そのアクション振る舞いを決めて検証事項を定義するものです。  
アクションは文字通り、プラグインに対して行われる/検証される動作（e.g. プレイヤのゲームモードの変更）を指定します。

:::warning

Scenamatica で使用される「シナリオ」という語は、以下の２つの意味を持ちます。

1. [コンテキスト](#context) や [トリガー](#trigger)、メイン[シナリオ](#scenario) などを含む、包括的な意味でのシナリオ。  
シナリオファイルに記述されるもの全体を包含した表現。
2. プラグインの振る舞いを検証するためのアクションとその振る舞いの組。

この項目では、後者の意味での「シナリオ」について説明しています。

```yaml

# このファイル自体を、シナリオファイルで記述された「シナリオ」と呼ぶ。

#...

scenario:
# ↓の一つ一つを「シナリオ」と呼ぶ。
- type: execute
  action: player_death
  with:
    target: Actor001 
- type: expect
  action: player_death
  with:
    target: Actor001 
```

:::

### シナリオの種類 {#scenario-type}

全てのシナリオは、以下の３つのタイプのいずれかに分類されます。詳しくは各項目の説明を参照してください。

1. [アクション実行(`execute`)](#scenario-type-action-execution)
2. [アクション実行期待(`expect`)](#scenario-type-action-execution-expect)
3. [条件要求(`require`)](#scenario-type-condition-require)

### アクション実行(`execute`) タイプ {#scenario-type-action-execution}

アクション実行(`execute`) タイプは、引数に指定されたアクションを実行し、完了するまでまたはタイムアウトするまで待機します。  
Scenamatica がテスト対象のプラグイン機能の実行を発火させるために使用します。

+ シナリオの成功条件
  1. アクションの実行が例外またはエラーなしで完了する。
+ シナリオの失敗条件
  1. アクションの実行がタイムアウトする。
  2. アクションの実行時に例外またはエラーが発生する。

### アクション実行期待(`expect`) タイプ {#scenario-type-action-execution-expect}

アクション実行期待(`expect`) タイプは、アクションが**プラグインによって**実行されるかどうかを検証します。  
指定されたアクションが実行されるまで、もしくはタイムアウトするまで次のシナリオの実行を待機します。

+ シナリオの成功条件
  1. 対象のプラグインによってアクションが実行される。
+ シナリオの失敗条件
  1. 検証がタイムアウトする。
  2. 後述された実行期待シナリオ(`expect`)のアクションが先に実行される（詳細後述）。

:::danger 後に実行されるべきアクションが繰り上げられて先に実行された場合は、このシナリオは失敗します。

例えば、以下のようなシナリオがあったとします：

+ アクション A を実行する
+ アクション B の実行を（プラグインによって行われるか）期待する
+ アクション C を実行を（〃）期待する

このとき、プラグインが機能を C -> B の順番で実行した場合は、このシナリオは C の実行とともに失敗します。

ただし、実行が失敗するのは、アクションの実行順序が不正な場合のみです。  
例えば「`指定されたメッセージ "Hoge" が送信されること`」を後に期待している場合に メッセージ "Fuga" が送信されたとしても、このシナリオは即座に**失敗しません**。  
そのあとに正しいメッセージが時間内に送信された場合は、このシナリオは**成功**します。
:::

### 条件要求(`require`) タイプ {#scenario-type-condition-require}

条件要求(`require`) タイプは、引数に指定された条件が**既に**満たされているか検証します。
この機能は、前述の[アクション実行期待タイプ](#scenario-type-action-execution-expect)を~~使いまわし~~応用したもので、
タイムアウトが `0`(固定) であることを除いて、ほとんど同じです。

例えば、以下のようなシナリオがあったとします：
1. アクション A を実行する
2. プレイヤ P がアイテム X を持っていること（条件）を**要求する**
3. アクション B を実行する

このシナリオでは、シナリオ 2 の到達時に Scenamatica はプレイヤ P がアイテム X を持っているかどうかを確認します。  
シナリオ 1 の実行完了と同じタイミング（同チック）に条件を満たしていない場合は、このシナリオは失敗します。

+ シナリオの成功条件
  1. 条件が（このシナリオの到達時に）満たされている。
+ シナリオの失敗条件
  1. 条件が（このシナリオの到達時に）満たされていない。

:::warning
このタイプはそのシナリオに到達する前に条件を満たしていることを確認するためのものです。

そのため、満たされるまで待機したり、タイムアウトまで待機する機能はありません。  
その場合は、代わりに[アクション実行期待(`expect`)](#scenario-type-action-execution-expect) タイプを使用してください。
:::

:::info 使用例

+ [条件付き実行](#conditional-execution)の条件の指定
+ JUnit のアサーションのような使用法

:::

### シナリオの例

#### 使用例：[アクション実行(`execute`)](#scenario-type-action-execution) タイプの [プレイヤの死亡およびキル](/docs/use/scenario/actions/player#death) アクション

この場合は、 Scenamatica は対象のプレイヤを殺害します。殺害に成功した場合は、シナリオは成功となります。

#### 使用例：[アクション実行期待(`expect`)](#scenario-type-action-execution-expect) タイプの [プレイヤの死亡およびキル](/docs/use/scenario/actions/player#death) アクション

この場合は、 Scenamatica はテスト対象のプラグインにより対象のプレイヤが殺害されるまで待機します。
殺害された場合は、シナリオは成功となります。  
一定時間が経過しても殺害されなかったり、**ファイルに後述されている他のシナリオが先に実行された場合**、シナリオは**失敗**となります。

#### 使用例：[条件要求(`require`)](#scenario-type-condition-require) タイプの [プレイヤの死亡およびキル](/docs/use/scenario/actions/player#death) アクション

この場合は、 Scenamatica はプレイヤが既に死亡しているかどうかを確認します。

:::warning

全てのアクションが全てのシナリオタイプで使用できるわけではありません。  
例えば、[メッセージ送信アクション](/docs/use/scenario/actions#message_) は、[条件要求(`require`)](#scenario-type-condition-require) タイプでは使用できません。  
これは、Scenamatica が既に送信されたメッセージを確認できないためです。

詳しくは各アクションのドキュメントを参照してください。

:::

## 実行順{#order}

この機能を使用すれば、同じ[シナリオセッション](/docs/use/test#scenario-session)内でのシナリオの実行順序を制御できます。

シナリオの実行順序は、シナリオファイルの `order` プロパティによって制御されます。  
これを設定しない場合や、順次指定が重複した場合は、自動的にシナリオの名前順でソートされます。

:::warning 実行順序の制御は**同一セッション内でのみ有効**です。

例えば、以下のようなシナリオとセッション（順不同）を考えます。

- シナリオA - `order: 1`
- シナリオB - `order: 2`
- シナリオC - `order: 3`
- シナリオD - \(未設定)

+ セッション\[0]
  + シナリオD
  + シナリオA
  + シナリオC
+ セッション\[1]
  + シナリオD
  + シナリオB

セッションはキューに追加された順に実行されますから、最終的なシナリオの実行順は `{D -> A -> C}` `->` `{D -> B}` となります。
:::

<BelowDocument docId={"use/scenario/types/README"}
               anchor="apex-order"
               label={"シナリオファイルの構文 | 実行順"}
/>

## コンテキスト {#context}

コンテキストは、[シナリオ](#scenario) を実行する[ステージ](#stage)（ワールド）や、
登場する[アクター](#actor)（プレイヤ）、[エンティティ](#entity) （モブ）を包含する、シナリオの実行環境のことです。  
シナリオの実行前に生成され、終了時に破棄されます。

:::tip

１つのシナリオに１つのコンテキストが割り当てられます。  
また、事前/事後シナリオ機能で実行されるシナリオは、メインシナリオと同じコンテキストを使用します。

:::

### ステージ {#stage}

ステージは、[シナリオ](#scenario) を実行するワールドのことです。シナリオ開始時に生成され、終了時にディレクトリごと削除されます。  
この機能は、シナリオ実行時のワールドの変更を完全に隔離し、実行後にワールドの状態を元に戻すために用意されています。

ステージの作成は以下の２方式があります。

1. 既存の Minecraft ワールドをコピーする。  
  既にサーバに存在するワールドをコピーすることで、建築物やエンティティをそのまま利用できます。
2. シード値/環境等を指定して新規に生成する。  
  この方式はシナリオの実行時に毎回ワールドを生成するので、毎回違う環境で実行できます。ただし、ワールドの生成はパフォーマンスに影響するため注意してください。

ステージの指定は、[シナリオファイルの `context`.`stage`](/docs/use/scenario/types#context-stage) プロパティによって行います。

### アクター {#actor}

アクターは、[シナリオ](#scenario) に登場する擬似的なプレイヤーです。シナリオ開始時に作成され、終了時に破棄されます。
また、アクタ－のログアウト時には、実績や権限、ほかのすべてのアクターに関するプレイヤーデータは削除されます。

この機能で生成されるプレイヤーは、通常のプレイヤーと同様に Minecraft サーバにログインします。
ですが、実際のソケット通信は行われず、 NMS を使用して Minecraft サーバの通信をエミュレートします。  
そのため、アクターに対して送られるパケットは、 `Packet(In/Out)KeepAlive` を除いて全て破棄されます。
 
:::tip

プラグイン側から `PlayerInventory#setHeldItemSlot(int)` などを使用した場合に `PlayerItemHeldEvent` が発火しないバグ（だと思っている）が存在します。
そのため、 Scenamatica ではこれを回避し、アクターに対するスロットの変更時に `PlayerItemHeldEvent` を発火させるようにしています。

ただし、同イベントのフィールドである `previousSlot` は技術的制約により `currentSlot` と同じ値になります。
:::

アクターの指定は、[シナリオファイルの `context`.`actors`](/docs/use/scenario/types#context-actors) プロパティによって行います。

### エンティティ {#entity}

エンティティは、シナリオに登場するモブのことです。ステージの準備後に生成され、終了時に破棄されます。
ステージに実際に生成され、通常の Minecraft エンティティと同様に、他のエンティティやプレイヤーとの相互作用が可能です。

Scenamatica はエンティティを削除されるまで継続して追跡し、そのエンティティを含むチャンクを強制的に読み込みます。  
これは、セレクタによるエンティティの指定を可能にするためです。

エンティティの指定は、[シナリオファイルの `context`.`entities`](/docs/use/scenario/types#context-entities) プロパティによって行います。

## 条件実行 {#conditional-execution}

指定の条件を満たした場合にのみ、シナリオまたはアクションを実行します。実行条件が満たされていない場合そのシナリオはスキップされますが、失敗とはみなされません。

条件の指定には、[条件要求(`require`)](#scenario-type-condition-require) タイプのシナリオに対応した[アクション](/docs/use/scenario/actions)を使用します。
詳しくは[条件要求タイプ(`require`)](#scenario-type-condition-require)および[アクション](/docs/use/scenario/actions)の項目を参照してください。

:::tip

シナリオ及び各トリガの実行条件は、**コンテキストの準備後**に評価されます。  
これは、条件の種類によってはコンテキストが必要な場合があるためです。

:::

