import BelowDocument from "/src/components/BelowDocument";
import { Object, ObjectType } from "/src/components/Object";


# シナリオファイルの構文

シナリオファイルの構文と書き方について説明します。

---

## 概要 {#overview}

:::tip

**シナリオやシナリオファイルの概念が初めての方は、先に[こちら](..)を参照して理解しておいてください。**

:::

シナリオファイルは、 `.yml` もしくは `.yaml` の拡張子を持つ YAML ファイルです。プラグインの .jar 内であれば場所は任意です。

１つのシナリオに付き１つのシナリオファイルが必要です。  
そのため、シナリオ用ディレクトリを作成し、その中にシナリオファイルを配置するのが一般的です。

## シナリオファイルの例 {#example}

シナリオファイルの例は

## JSON スキーマ {#json-schema}

シナリオファイルの完全な構文は、[JSON スキーマ](https://json-schema.org/)で定義されています。  
JSON スキーマは[こちら](https://raw.githubusercontent.com/TeamKun/Scenamatica/main/scenamatica-file.json) からダウンロードできます。

## シナリオファイルの構造 {#scenario-file-structure}

シナリオファイルは、頂点に以下の構造を持ちます。

<Object objects={[
  {
    name: "scenamatica",
    anchor: "apex-scenamatica",
    type: ObjectType.STRING,
    description: "Scenamatica のバージョンです。",
    required: true
  },
  {
    name: "name",
    anchor: "apex-name",
    type: ObjectType.STRING,
    description: "シナリオの一意の名前です。",
    required: true
  },
  {
    name: "description",
    anchor: "apex-description",
    type: ObjectType.STRING,
    description: "シナリオの人間が読みやすい説明です。",
    required: true
  },
  {
    name: "context",
    anchor: "apex-context",
    type: "Context",
    type_anchor: "context-structure",
    description: "シナリオのコンテキストです。"
  },
  {
    name: "triggers",
    anchor: "apex-triggers",
    type: "Trigger[]",
    type_anchor: "trigger-structure",
    description: "シナリオのトリガです。",
    required: true
  },
  {
    name: "runif",
    anchor: "apex-runif",
    type: "Action(type:require)",
    type_anchor: "action-structure",
    description: "シナリオを実行する条件です。"
  },
  {
    name: "scenario",
    anchor: "apex-scenario",
    type: "Scenario[]",
    type_anchor: "scenario-structure",
    description: "シナリオファイルの本シナリオです。",
    required: true
  }
]} />

### `scenamatica` {#apex-scenamatica}

全てのシナリオファイルには、 `scenamatica` という項目が必要です。これは技術的な制約によるものでもありますが、
Scenamatica が 検出した YAML ファイルをシナリオファイルかどうか判別するためにも使用されます。

この項目の値には、シナリオテスト時に使用できる**最も低い** Scenamatica のバージョンを指定します。  
これは、 サーバの Scenamatica に存在しない未来の機能を使用している場合に検出するためです。

通常は、検証サーバの Scenamatica のバージョンを指定すれば問題ありません。

:::caution

Scenamatica のバージョンは、 `x.y.z` の形式で指定します。  
また、指定されたバージョンよりも古いバージョンの Scenamatica ではシナリオファイルを読み込むことができません。

:::

### `name` {#apex-name}

シナリオのプラグイン内での一意の名前です、主に、 Scenamatica がシナリオを識別するために使用したり、**手動実行のコマンドの引数**に使用されます。

ファイル名に関しては技術的な制約等はありませんが、 Scenamatica では、以下のフォーマットを推奨します。

+ 拡張子は `.yml`
+ ASCII の小文字のみ
+ ケバブケース（単語をハイフンでつなぐ）
+ 推奨フォーマット： `test-<機能名>-<success|failure-with-[失敗内容]>.yml`  
  先頭を `test-機能名` にすることで、機能のテストということが分かりやすくなります。  
  また、正常に成功することを確認するテストの場合は `success`、
  異常入力等で失敗することを確認するテストの場合は `failure-with-<失敗内容>` というようにするとわかりやすいです。

例： `test-hoge-success.yml` 、 `test-hoge-failure-with-no-argument.yml`

:::tip

名前等の識別子のフォーマットは統一することが重要なので、 Scenamatica の推奨するフォーマットに従わなくても問題はありません。

:::

### `description` {#apex-description}

シナリオの人間が読みやすい説明です。

### `context` {#apex-context}

シナリオの実行に必要な環境を定義します。

:::tip

シナリオの実行に必要な環境とは、シナリオの登場人物や、シナリオを実行するワールド等のことです。  
これにより、シナリオ実行後のサーバ環境の状態をロールバックできるようになります。

:::

### `triggers` {#apex-triggers}

シナリオのトリガーを定義します。

シナリオはトリガーの発火によって実行されます。手動実行する場合もこれは例外ではなく、それに対応したトリガが必要です。

### `runif` {#apex-runif}

シナリオを実行する条件をアクションで定義します。

:::info

条件に一致しなかった場合、テストは `SKIPPED` で終了します（エラーにはなりません）。

:::

### `scenario` {#apex-scenario}

シナリオファイルの本シナリオです。シナリオを定義するのに使用します。

## コンテキスト型 {#context-structure}

コンテキストは、以下の構造を持ちます。

<Object objects={[
  {
    name: "actors",
    anchor: "context-actors",
    type: "Actor[]",
    type_anchor: "actor-structure",
    description: "シナリオの実行に必要なアクターを定義します。"
  },
  {
    name: "stage",
    anchor: "context-stage",
    type: "Stage",
    type_anchor: "stage-structure",
    description: "シナリオの実行に必要なステージを定義します。"
  },
]} />

### `actors` {#context-actors}

シナリオの実行に必要なアクターを定義します。

アクターに関しては、[こちら](elements/#actor)を参照してください。

### `stage` {#context-stage}

シナリオの実行に必要なステージを定義します。  

ステージに関しては、[こちら](elements/#stage)を参照してください。

## トリガ型 {#trigger-structure}

トリガーは、以下の構造を持ちます。

<Object objects={[
  {
    name: "type",
    anchor: "trigger-type",
    type: "string",
    description: "トリガーの種類です。",
    required: true
  },
  {
    name: "before",
    anchor: "trigger-before",
    type: "Scenario[]",
    type_anchor: "scenario-structure",
    description: "本シナリオの実行前に実行するシナリオの定義です。"
  },
  {
    name: "after",
    anchor: "trigger-after",
    type: "Scenario[]",
    type_anchor: "scenario-structure",
    description: "本シナリオの実行後に実行するシナリオの定義です。"
  },
  {
    name: "runif",
    anchor: "trigger-runif",
    type: "Action(type:require)",
    type_anchor: "action-structure",
    description: "本シナリオの実行条件をアクションで定義します。"
  },
  {
    name: "...",
    type: "...",
    description: "トリガの引数を指定します。",
    default: "..."
  },
]} />

:::caution

トリガにおける引数の概念は一見無いように見えますが、実際には存在します。  
トリガーの種類によっては必要になるものがありますので、それぞれのトリガーの説明を参照してください。

また、引数の指定用のキー等はないので、このトリガの構造に直に追記してください。

:::

### `type` {#trigger-type}

トリガーの種類です。

<BelowDocument docId="use/scenario/triggers"
               anchor="triggers"
               label="有効なトリガの種類"
               message="有効なトリガの種類の一覧はこちらを参照してください。"
/>

### `before` {#trigger-before}

本シナリオの実行前に実行するシナリオ（事前シナリオ）の定義です。

シナリオの定義は、[こちら](elements/#scenario)を参照してください。

:::caution

事前シナリオは、本シナリオのコンテキストと同じコンテキストで実行されます。

:::

### `after` {#trigger-after}

本シナリオの実行後に実行するシナリオ（事後シナリオ）の定義です。

シナリオの定義は、[こちら](elements/#scenario)を参照してください。

:::caution

事後シナリオは、本シナリオのコンテキストと同じコンテキストで実行されます。

:::

### `runif` {#trigger-runif}

トリガごとに、シナリオの実行条件をアクションで定義します。  
シナリオのルートで定義されている場合、両方の条件が満たされた場合に実行されます。

## ステージ型 {#stage-structure}

ステージは、以下の構造を持ちます。

<Object objects={[
  {
    name: "copyOf",
    anchor: "stage-copyOf",
    type: "string",
    description: "オリジナルのワールドの名前です。"
  },
  {
    name: "type",
    anchor: "stage-type",
    type: "string",
    description: "ステージとして使用するワールドの種類です。",
    default: "normal"
  },
  {
    name: "seed",
    anchor: "stage-seed",
    type: "number",
    description: "ステージとして使用するワールドのシードです。"
  },
  {
    name: "structures",
    anchor: "stage-structures",
    type: "boolean",
    description: "ステージとして使用するワールドに構造物を生成するかどうかです。",
    default: true
  },
  {
    name: "env",
    anchor: "stage-env",
    type: "string",
    description: "ステージとして使用するワールドの環境です。",
    default: "normal"
  },
  {
    name: "hardcore",
    anchor: "stage-hardcore",
    type: "boolean",
    description: "ステージとして使用するワールドがハードコアかどうかです。",
    default: false
  },
]} />

### `copyOf` {#stage-copyOf}

オリジナルのワールドの名前です。  
Bukkit でロード済みの既存のワールドの構造、建築物、アイテム、エンティティおよびすべての設定をコピーして、ステージ化します。

:::warning

これを設定した場合、他の設定は**全て無視されます**。

他の設定は新規ワールドを生成する際の設定となります。したがって、ワールドをコピーしてステージ化する本機能においては、他の設定は使用できません。

:::

### `type` {#stage-type}

ステージとして使用するワールドの種類です。Minecraft の `level-type` と同じです。以下の種類が指定できます。

| 種類            | 説明               |
|---------------|------------------|
| `NORMAL`      | 通常のワールドです。       |
| `FLAT`        | スーパーフラットのワールドです。 |
| `LARGEBIOMES` | ラージバイオームのワールドです。 |
| `AMPLIFIED`   | アンプリファイドのワールドです。 |
| `CUSTOMIZED`  | カスタマイズされたワールドです。 |

### `seed` {#stage-seed}

ステージとして使用するワールドのシードです。

:::caution

値は Long 型です。

:::

### `structures` {#stage-structures}

ステージとして使用するワールドに構造物を生成するかどうかです。

### `env` {#stage-env}

ステージとして使用するワールドの環境です。以下の環境が指定できます。

| 環境        | 説明         |
|-----------|------------|
| `NORMAL`  | 通常のワールドです。 |
| `NETHER`  | ネザーワールドです。 |
| `THE_END` | エンドワールドです。 |

### `hardcore` {#stage-hardcore}

ステージとして使用するワールドがハードコアかどうかです。

## シナリオ型 {#scenario-structure}

シナリオは、以下の構造を持ちます。

<Object objects={[
  {
    name: "type",
    anchor: "scenario-type",
    type: "列挙値{expect, execute, require}",
    description: "シナリオの種類です。"
  },
  {
    name: "action",
    anchor: "scenario-action",
    type: "Action",
    typeLink: "action-structure",
    description: "シナリオのアクションです。"
  },
  {
    name: "timeout",
    anchor: "scenario-timeout",
    type: "number",
    description: "シナリオのタイムアウト時間のチック数です。",
    default: -1
  },
  {
    name: "runif",
    anchor: "scenario-runif",
    type: "Action(type: require)",
    typeLink: "action-structure",
    description: "シナリオの実行条件です。"
  }
]} />

### `type` {#scenario-type}

シナリオの種類です。以下の種類が指定できます。

+ `expect`  
  期待するアクションを実行するシナリオです。  
  対象のアクションが行われるまで、または指定されたアイムアウトまで待機します。
  アクションが行われた場合はシナリオは成功し、アクションが行われなかった場合は失敗します。
+ `execute`
  アクションを実行するシナリオです。  
  対象のアクションを実行します。  
  アクションが行われた場合はシナリオは成功し、アクションがタイムアウトまでに行われなかった場合、例外が発せ敷いた場合は失敗します。
+ `require`
  コンディションを満たしているかどうかを確認するシナリオです。wwwww
  対象のアクションと紐づいているコンディションを満たしているかどうかを確認します。

  :::caution

  このシナリオは、コンディションを**既に**満たしているかどうかのみ確認します。  
  コンディションが満たされなかた場合に待機等は行われず、即刻失敗します。
  
  このシナリオにおけるタイムアウト指定は無視されます。

  :::

### `action` {#scenario-action}

シナリオのアクションです。

### `timeout` {#scenario-timeout}

シナリオのタイムアウト時間のチック数です。

:::tip

`-1` を指定すると、タイムアウトは無効になり、無限に待機します。

:::

### `runif` {#scenario-runif}

このシナリオが実行される前に、このシナリオのアクションと紐づいているコンディションが満たされているかどうかを確認します。  
満たされていない場合は、このシナリオはスキップされます。

## アクション型 {#action-structure}

アクションは、以下の構造を持ちます。

<Object objects={[
  {
    name: "type",
    anchor: "action-type",
    type: "列挙値{...}",
    description: "アクションの種類です。",
    required: true
  },
  {
    name: "with",
    anchor: "action-with",
    type: ObjectType.OBJECT,
    description: "アクションのパラメータです。"
  },
]} />

### `type` {#action-type}

アクションの種類です。

<BelowDocument docId={"use/scenario/actions/README"}
               anchor={"actions"}
               label={"アクションの種類"}
               message={"アクションの種類については、以下を参照してください。"} 
/>

### `with` {#action-with}

アクションのパラメータです。  
アクションの種類によっては、パラメータが必要な場合があります。

詳しくは、該当するアクションのページを参照してください。


## シナリオファイルを記述する際の注意 {#notes}

### YAML のキーの命名規則 {#yaml-key-naming-rules}

Scenamatica のシナリオファイルにおける YAML のキーは、原則として以下の命名規則に従います。

+ `camelCase` で記述します。
+ Minecraft 固有の単語は区切らずに記述します。  
  例： `gamemode`, `minecraft` など
+ プレイヤ系アクションにおける、対象のターゲットは全て キー `target` で指定します。  
  例： ゲームモードを変更するアクションの場合、 `target` に対象のプレイヤを指定します。

Scenamatica のシナリオファイルにおける YAML のキーは、原則

### 列挙値におけるシンタックスシュガー {#syntax-sugar-on-enum-values}

一部のアクションの引数には、 Minecraft/Bukkit 固有の列挙値（例： `GameMode`, `Material` など）が指定できます。  
Scenamatica では、これらの記述のシンタックスシュガーとして、列挙値の名前の大小文字を無視します。

例：
+ `gamemode: SURVIVAL` は `gamemode: survival` と同じ意味です。
+ `material: STONE` は `material: Stone` と同じ意味です。

### プレイヤの指定におけるシンタックスシュガー {#syntax-sugar-on-player}

一部のアクションの引数には、プレイヤ（の名前）を引数として指定できます。  
上記と同じく、プレイヤの名前の大小文字を無視します。
これに加えて、プレイヤは **UUID** でも指定できます。

例（サーバに Player1(00000000-1111-2222-3333-444444444444) というプレイヤが参加している場合）：
+ `player: player1` は `player: Player1` と同じ意味です。
+ `player: 00000000-1111-2222-3333-444444444444` は内部的に `player: Player1` と同じ意味です。
