---
sidebar_position: 2
---


import BelowDocument from "/src/components/BelowDocument";

# シナリオの要素

Scenamatica のシナリオを構成する要素について説明しています。

---

:::tip


このページでは, シナリオの具体的な要素について説明しています。  
シナリオファイルの構文や実践的な書き方については以下のページを参照してください。

+ [シナリオファイルの構文](/docs/use/scenario/scenario-file)
+ [チュートリアル：最初のシナリオを書いてみる](/docs/getting-started/tutorials/writing-my-first-scenario)

:::

## 概要 {#about}

シナリオは以下の要素で構成されています。

+ **メタデータ**  
  Scenamatica がシナリオ（ファイル）を識別する情報について記述します。
+ **[トリガ](/docs/use/scenario/trigger)**  
  シナリオテストが発火する条件について記述します。
+ **[実行順](#order)**  
  シナリオテストを実行する順番について記述します。  
  プラグインの[スタートアップ時に実行](/docs/use/scenario/trigger#triggers-on-load)されるシナリオなど, 
  同時に他のシナリオが複数発火する場合などに, その中での実行順を制御します。
+ **[コンテキスト](#context)**  
  シナリオテストを実行するために, 必要な前提環境（e.g. ワールド, プレイヤ, モブ・エンティティ）について記述します。
+ **[メインシナリオ](#scenario)**  
  プラグイン機能を発火させたり, 発火した機能を検証するためのフローを記述します。
+ **[実行条件](#conditional-execution)**  
  シナリオの実行に必要な条件（e.g. [マイルストーン](/docs/use/scenario/milestone)）について記述します。
+ **[定数の定義](/docs/use/scenario/variables-and-definitions)**  
  使いまわしする値や構造体について記述します。


### シナリオ YAML ファイルと要素の対応 {#yaml-element-pair}

```yaml showLineNumbers
# メタデータ
scenamatica: "0.8.0"
name: "test-hoge-success"
description: "hoge 機能の正常系テスト"

# highlight-start
runif:  # 実行条件：hoge-milestone を達成している場合に実行する
  action: milestone
  with:
    name: hoge-milestone
# highlight-end

# highlight-start
context:  # コンテキスト
  actors:  # コンテキスト：アクタ
  - name: Actor1
    permissions:
    - "hogeplugin.commands.hoge"
  stage:  # コンテキスト：ステージ
    env: NETHER
    seed: 114514
# highlight-end

# highlight-start
on:  # トリガ
- type: on_load  # トリガ：プラグインのスタートアップ時に実行
- type: manual_dispatch  # トリガ：Scenamatica のコマンドで実行
#highlight-end

# highlight-start
scenario:  # シナリオ
  # Actor1 が /hoge を実行する。
- type: execute
  action: command_dispatch
  with:
    command: "/hoge"
    sender: Actor1
  # fuga というメッセージが（Actor1 に）表示される。
- type: expect
  action: message
  with:
    content: "fuga"
    recipient: "${scenario.scenario.0.sender}"  # 変数：前のアクションの実行者を指定
  # Actor1 が死亡する。
- type: expect
  action: player_death
  with:
    target: "${scenario.scenario.0.sender}"  # 変数：前のアクションの実行者を指定
#highlight-end
 ```

## シナリオ {#scenario}

プラグイン開発者は, プラグインの大まかな入出力をシナリオとして記述します。
そして Scenamatica はこれらを一つ一つ実行・検証し, プラグインの振る舞いをテストします。
実行・検証に失敗した場合は,  Scenamatica はプラグインが正しく動作していないと判断し, シナリオ実行の失敗を報告します。

### シナリオの種類 {#scenario-type}

全てのシナリオは, 以下の３つのタイプのいずれかに分類されます。詳しくは各項目の説明を参照してください。

1. [アクション実行(`execute`)](#scenario-type-action-execution)
2. [アクション実行期待(`expect`)](#scenario-type-action-execution-expect)
3. [条件要求(`require`)](#scenario-type-condition-require)

### アクション実行(`execute`) タイプ {#scenario-type-action-execution}

アクション実行(`execute`) タイプは, 引数に指定されたアクションを実行し, 完了するまでまたはタイムアウトするまで待機します。  
Scenamatica がテスト対象のプラグイン機能の実行を発火させるために使用します。

+ シナリオの成功条件
  1. アクションの実行が例外またはエラーなしで完了する。
+ シナリオの失敗条件
  1. アクションの実行がタイムアウトする。
  2. アクションの実行時に例外またはエラーが発生する。

### アクション実行期待(`expect`) タイプ {#scenario-type-action-execution-expect}

アクション実行期待(`expect`) タイプは, アクションが**プラグインによって**実行されるかどうかを検証します。  
指定されたアクションが実行されるまで, もしくはタイムアウトするまで次のシナリオの実行を待機します。

+ シナリオの成功条件
  1. 対象のプラグインによってアクションが実行される。
+ シナリオの失敗条件
  1. 検証がタイムアウトする。
  2. 後述された実行期待シナリオ(`expect`)のアクションが先に実行される（詳細後述）。

:::danger 後に実行されるべきアクションが繰り上げられて先に実行された場合は, このシナリオは失敗します。

例えば, 以下のようなシナリオがあったとします：

+ アクション A を実行する
+ アクション B の実行を（プラグインによって行われるか）期待する
+ アクション C を実行を（〃）期待する

このとき, プラグインが機能を C -> B の順番で実行した場合は, このシナリオは C の実行とともに失敗します。

ただし, 実行が失敗するのは, アクションの実行順序が不正な場合のみです。  
例えば「`指定されたメッセージ "Hoge" が送信されること`」を後に期待している場合に メッセージ "Fuga" が送信されたとしても, このシナリオは即座に**失敗しません**。  
そのあとに正しいメッセージが時間内に送信された場合は, このシナリオは**成功**します。
:::

### 条件要求(`require`) タイプ {#scenario-type-condition-require}

条件要求(`require`) タイプは, 引数に指定された条件が**既に**満たされているか検証します。
この機能は, 前述の[アクション実行期待タイプ](#scenario-type-action-execution-expect)を~~使いまわし~~応用したもので, 
タイムアウトが `0`(固定) であることを除いて, ほとんど同じです。

例えば, 以下のようなシナリオがあったとします：
1. アクション A を実行する
2. プレイヤ P がアイテム X を持っていること（条件）を**要求する**
3. アクション B を実行する

このシナリオでは, シナリオ 2 の到達時に Scenamatica はプレイヤ P がアイテム X を持っているかどうかを確認します。  
シナリオ 1 の実行完了と同じタイミング（同チック）に条件を満たしていない場合は, このシナリオは失敗します。

+ シナリオの成功条件
  1. 条件が（このシナリオの到達時に）満たされている。
+ シナリオの失敗条件
  1. 条件が（このシナリオの到達時に）満たされていない。

:::warning
このタイプはそのシナリオに到達する前に条件を満たしていることを確認するためのものです。

そのため, 満たされるまで待機したり, タイムアウトまで待機する機能はありません。  
その場合は, 代わりに[アクション実行期待(`expect`)](#scenario-type-action-execution-expect) タイプを使用してください。
:::

:::info 使用例

+ [条件付き実行](#conditional-execution)の条件の指定
+ JUnit のアサーションのような使用法

:::

### シナリオの例

#### 使用例：[アクション実行(`execute`)](#scenario-type-action-execution) タイプの [プレイヤの死亡およびキル](/references/actions/players/player_death) アクション

この場合は,  Scenamatica は対象のプレイヤを殺害します。殺害に成功した場合は, シナリオは成功となります。

#### 使用例：[アクション実行期待(`expect`)](#scenario-type-action-execution-expect) タイプの [プレイヤの死亡およびキル](/references/actions/players/player_death) アクション

この場合は,  Scenamatica はテスト対象のプラグインにより対象のプレイヤが殺害されるまで待機します。
殺害された場合は, シナリオは成功となります。  
一定時間が経過しても殺害されなかったり, **ファイルに後述されている他のシナリオが先に実行された場合**, シナリオは**失敗**となります。

#### 使用例：[条件要求(`require`)](#scenario-type-condition-require) タイプの [プレイヤの死亡およびキル](/references/actions/players/player_death) アクション

この場合は,  Scenamatica はプレイヤが既に死亡しているかどうかを確認します。

:::warning

全てのアクションが全てのシナリオタイプで使用できるわけではありません。  
例えば, [メッセージ送信アクション](/references/actions#message_) は, [条件要求(`require`)](#scenario-type-condition-require) タイプでは使用できません。  
これは, Scenamatica が既に送信されたメッセージを確認できないためです。

詳しくは各アクションのドキュメントを参照してください。

:::

## 実行順{#order}

この機能を使用すれば, 同じ[シナリオセッション](/docs/use/test#scenario-session)内でのシナリオの実行順序を制御できます。

シナリオの実行順序は, シナリオファイルの `order` プロパティによって制御されます。  
これを設定しない場合や, 順次指定が重複した場合は, 自動的にシナリオの名前順でソートされます。

:::warning 実行順序の制御は**同一セッション内でのみ有効**です。

例えば, 以下のようなシナリオとセッション（順不同）を考えます。

- シナリオA - `order: 1`
- シナリオB - `order: 2`
- シナリオC - `order: 3`
- シナリオD - \(未設定)

+ セッション\[0]
  + シナリオD
  + シナリオA
  + シナリオC
+ セッション\[1]
  + シナリオD
  + シナリオB

セッションはキューに追加された順に実行されますから, 最終的なシナリオの実行順は `{D -> A -> C}` `->` `{D -> B}` となります。
:::

これは, シナリオファイルの[`order`](/references/types/#apex-order)プロパティによって指定されます。


## コンテキスト {#context}

コンテキストは, [シナリオ](#scenario) を実行する[ステージ](#stage)（ワールド）や, 
登場する[アクタ](#actor)（プレイヤ）, [エンティティ](#entity) （モブ）を包含する, シナリオの実行環境のことです。  
シナリオの実行前に生成され, 終了時に破棄されます。

:::tip

１つのシナリオに１つのコンテキストが割り当てられます。  
また, 事前/事後シナリオ機能で実行されるシナリオは, メインシナリオと同じコンテキストを使用します。

:::

### ステージ {#stage}

ステージは, [シナリオ](#scenario) を実行するワールドのことです。シナリオ開始時に生成され, 終了時にディレクトリごと削除されます。  
この機能は, シナリオ実行時のワールドの変更を完全に隔離し, 実行後にワールドの状態を元に戻すために用意されています。

ステージの作成は以下の２方式があります。

1. 既存の Minecraft ワールドをコピーする。  
  既にサーバに存在するワールドをコピーすることで, 建築物やエンティティをそのまま利用できます。
2. シード値/環境等を指定して新規に生成する。  
  この方式はシナリオの実行時に毎回ワールドを生成するので, 毎回違う環境で実行できます。ただし, ワールドの生成はパフォーマンスに影響するため注意してください。

ステージの指定は, [シナリオファイルの `context`.`stage`](/references/types#context-stage) プロパティによって行います。

### アクタ {#actor}

アクタは, [シナリオ](#scenario) に登場する擬似的なプレイヤです。シナリオ開始時に作成され, 終了時に破棄されます。
また, アクタ－のログアウト時には, 実績や権限, ほかのすべてのアクタに関するプレイヤデータは削除されます。

この機能で生成されるプレイヤは, 通常のプレイヤと同様に Minecraft サーバにログインします。
ですが, 実際のソケット通信は行われず,  NMS を使用して Minecraft サーバの通信をエミュレートします。  
そのため, アクタに対して送られるパケットは,  `Packet(In/Out)KeepAlive` を除いて全て破棄されます。
 
:::tip

プラグイン側から `PlayerInventory#setHeldItemSlot(int)` などを使用した場合に `PlayerItemHeldEvent` が発火しないバグ（だと思っている）が存在します。
そのため,  Scenamatica ではこれを回避し, アクタに対するスロットの変更時に `PlayerItemHeldEvent` を発火させるようにしています。

ただし, 同イベントのフィールドである `previousSlot` は技術的制約により `currentSlot` と同じ値になります。
:::

アクタの指定は, [シナリオファイルの `context`.`actors`](/references/types#context-actors) プロパティによって行います。

### エンティティ {#entity}

エンティティは, シナリオに登場するモブのことです。ステージの準備後に生成され, 終了時に破棄されます。
ステージに実際に生成され, 通常の Minecraft エンティティと同様に, 他のエンティティやプレイヤとの相互作用が可能です。

Scenamatica はエンティティを削除されるまで継続して追跡し, そのエンティティを含むチャンクを強制的に読み込みます。

エンティティの指定は, [シナリオファイルの `context`.`entities`](/references/types#context-entities) プロパティによって行います。

## 条件実行 {#conditional-execution}

指定の条件を満たした場合にのみ, シナリオまたはアクションを実行します。実行条件が満たされていない場合そのシナリオはスキップされますが, 失敗とはみなされません。

条件の指定には, [条件要求(`require`)](#scenario-type-condition-require) タイプのシナリオに対応した[アクション](/references/actions)を使用します。
詳しくは[条件要求タイプ(`require`)](#scenario-type-condition-require)および[アクション](/references/actions)の項目を参照してください。

:::tip

シナリオ及び各トリガの実行条件は, **コンテキストの準備後**に評価されます。  
これは, 条件の種類によってはコンテキストが必要な場合があるためです。

:::

